#!/usr/bin/env bash

# Default config
TALL_RATIO=0.6;
WIDE_RATIO=0.6;
DESKTOP_STATE="/tmp/bsp-layout.state/desktops";

get_focused_desktop() { bspc query -D -d 'focused' --names; }
get_desktop_name_from_id() { bspc query -D -d "$1" --names; }

jget() {
    key=$1
    shift
    var=${*#*\"$key\":}
    var=${var%%[,\}]*}
    echo "$var"
}

# amend the split type so we are arranged correctly
rotate() {
  node=$1;
  want=$2;
  have=$(jget splitType "$(bspc query -T -n "$node")");
  have=${have:1:${#have}-2};
  angle=$3;

  if [[ ! "$have" = "$want" ]]; then
    bspc node "$node" -R "$3";
  fi
}

auto_balance() { bspc node "$1" -B; }

# :: DesktopName -> Key -> Value -> ()
set_desktop_option() {
  new_options=$(get_desktop_options "$1" | append_option $2 $3);
  mkdir -p "$DESKTOP_STATE";
  echo "$new_options" > "$DESKTOP_STATE/$1";
}

master_size=$TALL_RATIO;

tall() {

  # ensure the count of the master child is 1, or make it so
  nodes=($(bspc query -N '@/1' -n .descendant_of.window.!hidden))
  win_count=$(echo "$nodes" | wc -l)

  if [ $win_count -ne 1 ]; then
    new_node=$(bspc query -N '@/1' -n last.descendant_of.window.!hidden | head -n 1);

    if [ -z "$new_node" ]; then
      new_node=$(bspc query -N '@/2' -n last.descendant_of.window.!hidden | head -n 1);
    fi

    root=$(echo "$nodes" | head -n 1);

    # move everything into 2 that is not our new_node
    for wid in $(bspc query -N '@/1' -n .descendant_of.window.!hidden | grep -v $root); do
      bspc node "$wid" -n '@/2';
    done

    bspc node "$root" -n '@/1';
  fi

  rotate '@/' vertical 90;
  rotate '@/2' horizontal 90;

  stack_node=$(bspc query -N '@/2' -n);
  for parent in $(bspc query -N '@/2' -n .descendant_of.!window.!hidden | grep -v $stack_node); do
    rotate $parent horizontal 90;
  done

  auto_balance '@/2';

  local mon_width=$(jget width "$(bspc query -T -m)");

  ((want=master_size*mon_width))
  local have=$(jget width "$(bspc query -T -n '@/1')");

  bspc node '@/1' --resize right $((want - have)) 0;
}

run_layout() {
  tall
}

start_listener() {
  layout=$1; shift;
  selected_desktop=$1; shift;
  [[ "$selected_desktop" == "--" ]] && selected_desktop="";

  args=$@;

  [[ -z "$selected_desktop" ]] && selected_desktop=$(get_focused_desktop);

  # If it is a bsp default layout, set that
  if (echo -e "$BSP_DEFAULT_LAYOUTS" | grep "^$layout$"); then
    remove_listener "$selected_desktop";
    bspc desktop "$selected_desktop" -l "$layout";
    exit 0;
  fi

  recalculate_layout() { run_layout $layout $args 2> /dev/null || true; }

  # Recalculate styles as soon as they are set if it is on the selected desktop
  [[ "$(get_focused_desktop)" = "$selected_desktop" ]] && recalculate_layout;

  # Then listen to node changes and recalculate as required
  bspc subscribe node_{add,remove,transfer}  | while read line; do
    set "$line"
    event=$1
    arg_index=$([[ "$event" == "node_transfer" ]] && echo "6" || echo "3");
    desktop_id=$(echo "$line" | awk "{print \$$arg_index}");
    desktop_name=$(get_desktop_name_from_id "$desktop_id");

    [[ "$desktop_name" = "$selected_desktop" ]] && recalculate_layout;
  done &

  LAYOUT_PID=$!; # PID of the listener in the background
  disown;

  # Kill old layout
  kill_layout $selected_desktop;

  # Set current layout
  set_desktop_option $selected_desktop 'layout' "$layout";
  set_desktop_option $selected_desktop 'pid'    "$LAYOUT_PID";

  echo "[$LAYOUT_PID]";
}

reload_layouts() {
  list_desktops | while read desktop; do
    layout=$(get_desktop_options "$desktop" | valueof layout);
    [[ ! -z "$layout" ]] && start_listener $layout $desktop;
  done;
}

action=$1; shift;

case "$action" in
  reload)     reload_layouts ;;
  once)       run_layout "$1" ;;
  set)        start_listener "$@" ;;
  get)        layout=$(get_desktop_options "$1" | valueof layout); echo "${layout:-"default"}" ;;
  remove)     remove_listener "$1" ;;
  layouts)    echo -e "$BSP_DEFAULT_LAYOUTS"; ls "$LAYOUTS" | sed -e 's/\.sh$//'; ;;
  help)       echo -e "$HELP_TEXT" ;;
  version)    echo "$VERSION" ;;
  *)          echo -e "$HELP_TEXT" && exit 1 ;;
esac

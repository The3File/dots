#!/usr/bin/env bash

fz(){ fzf --ansi --height 40% --reverse "$@";}

editor(){ nvim +"set ft=markdown" "$@";}

new(){
	prep_tmp
	editor +startinsert $tmp
	read -rep "new name: " new_name
	mv_tmp
}

edit(){
	get_note edit
	[[ -f "$note" ]] && editor "$note"
}

delete(){
	get_note delete
	read -rp "delete "$note"? [y/N] " r
	[[ $r =~ y|Y ]] && rm "$note"
}

move(){
	get_note move
	read -rep "new name: " new_name
	mv "$note" "${new_name}.md" -v -i
}

show(){
	printf '\e[1m%s\n\e[m%s\n' "entering subshell..."\
		"ctrl+d to return"
	exec $SHELL
}

prep_tmp(){
	tmp="$(mktemp)"
	print_tags > $tmp
}

mv_tmp(){
	fallback="note_$(date '+%d-%m_%H%M')"
	mv "$tmp" "${new_name:-$fallback}.md" -v -i
}

sync(){
	status=$(git status --porcelain)
	[[ -z "$status" ]] && pull || push
}

push(){
	git add .; git commit -m "$status"
	git push -u origin master
}

pull(){
	printf '%s\n' "No changes, checking remote.."
	git pull
}

get_note(){
	note="$(print_notes | fz --prompt="$1 > " -q "$q")"
	[[ -z "$note" ]] && exit 0
}

print_notes(){
	IFS=$'\n' read -rd '' -a notes < <(fd -c always .md $NOTES)
	printf '%s\n' "${notes[@]#*${NOTES##*/}/}"
}

print_tags(){
	printf '\n\n%s\n%s' "[//]: # ($(date -Iseconds))"\
		"[//]: # (tags: [<++>])"
}

print_opts(){
	opts=("new" "sync" "edit" "delete" "move" "show")
	printf '%s\n' "${opts[@]}"
}

get_opts(){
	opt=$(print_opts | fz -0 -1 -q "$1")
	q="$2"
	[[ $opt ]] || false
}

main(){
	[[ "$NOTES" ]] && cd "$NOTES" || return 1
	get_opts "$@" || exit
	eval "$opt"
}

main "$@"
